structures:
   equivalence:
      add:
         cypher: |
            // find s, t nodes
            MERGE (s:_ {id: {source}})
            ON CREATE SET s :_:_VACANT
            MERGE (t:_ {id: {target}})
            ON CREATE SET t :_:_VACANT
            WITH s,t

            // remove all equivalence class nodes
            OPTIONAL MATCH (s) <-[:`=`]- (se:`=`)
            OPTIONAL MATCH (t) <-[:`=`]- (te:`=`)
            OPTIONAL MATCH () <-[x:`=`]- (se)
            OPTIONAL MATCH () <-[y:`=`]- (te)
            WITH s, t, se, te,
                 collect(DISTINCT x) AS a1,
                 collect(DISTINCT y) AS a2

            FOREACH (a IN a1 | DELETE a)
            FOREACH (a IN a2 | DELETE a)

            DELETE se
            DELETE te

            WITH s, t

            // create equivalence class node
            MERGE (s) <-[:`=`]- (eq:`=`) -[:`=`]-> (t)

            // create relation node
            MERGE (s) -[:«type»]-> (r:_:_Rel {id: {id}}) -[:«type»]-> (t)
            SET r.dataset = {dataset}

            // find all nodes reachable under the euivalence relation
            WITH s, t, r, eq
            MATCH (s) -[:«type» * 0 .. 12]- (n:_)
            WHERE NOT n:_Rel // skip the relation nodes
                  AND n <> s // don't include s, already have arc
                  AND n <> t // don't include t, already have arc

            WITH s, t, r, eq, collect(DISTINCT n) AS members
            FOREACH (m IN members | 
              CREATE (eq) -[:`=`]-> (m) )

            RETURN s, t, r, eq
      remove:
         cypher: |
            // find s, t nodes
            MATCH (r:_:_Rel {id: {id}})
            MATCH (s) -[x:«type»]-> (r) -[y:«type»]-> (t)
            DELETE x, y, r

            WITH s, t

            // remove all equivalence class nodes
            OPTIONAL MATCH (s) <-[:`=`]- (se:`=`)
            OPTIONAL MATCH (t) <-[:`=`]- (te:`=`)
            OPTIONAL MATCH () <-[x:`=`]- (se)
            OPTIONAL MATCH () <-[y:`=`]- (te)
            WITH s, t, se, te,
                 collect(DISTINCT x) AS a1,
                 collect(DISTINCT y) AS a2

            FOREACH (a IN a1 | DELETE a)
            FOREACH (a IN a2 | DELETE a)

            DELETE se
            DELETE te

            WITH s, t

            // create equivalence class nodes for s and t
            MERGE (s) <-[:`=`]- (s_ec:`=`)
            MERGE (t) <-[:`=`]- (t_ec:`=`)

            WITH s, t, s_ec, t_ec

            // find all nodes reachable from s under the euivalence relation
            MATCH (s) -[:«type» * 0 .. 12]- (n:_)
            WHERE NOT n:_Rel // skip the relation nodes
                  AND n <> s // don't include s, already have arc

            MATCH (t) -[:«type» * 0 .. 12]- (m:_)
            WHERE NOT m:_Rel // skip the relation nodes
                  AND m <> t // don't include s, already have arc

            WITH s, t, s_ec, t_ec,
                 collect(DISTINCT n) AS s_members,
                 collect(DISTINCT m) AS t_members

            FOREACH (n IN s_members | 
              CREATE (s_ec) -[:`=`]-> (n) )

            FOREACH (n IN t_members | 
              CREATE (t_ec) -[:`=`]-> (n) )

            RETURN s, t, s_ec, t_ec
   node:
      add:
         ruleset:
            - |  x  => (*)
            - | ( ) => (*)
            - | (*) => 500
         cypher: |
            MERGE (n:_:_VACANT:«type» {id: {id}})
            ON CREATE
               SET n = {doc},
                  n.created = timestamp(),
                  n.id = {id}
                  n.dataset = {dataset}
            ON MATCH
               SET n = {doc},
                   n.accessTime = timestamp(),
                  n.counter = coalesce(n.counter, 0) + 1,
                  n.id = {id}
                  n.dataset = {dataset}
               REMOVE n:_VACANT
            RETURN n
      update:
         ruleset:
            - |  x  => 404
            - | ( ) => (*)
            - | (*) => (*)
         cypher: |
            MATCH (n:_ {id: {id}})
            WITH n, coalesce(n.counter, 0) + 1 AS c
            SET n = {doc},
                n.accessTime = timestamp(),
                n.counter = c,
                n.id = {id}
                n.dataset = {dataset}
            RETURN n
      remove:
         ruleset:
            - |    x  => 404
            - | --( ) => 404
            - |   (*) => x
            - | --(*) => --( )
         cypher: |
            MATCH (n:_ {id: {id}})
            WHERE NOT n:_VACANT
               SET n:_VACANT
               SET n={}
               SET n.id = {id}
            UNION ALL
            OPTIONAL MATCH (n:_:_VACANT {id: {id}})
            WHERE length( (n)--() ) = 0
            DELETE n
            RETURN n
   edge:
      add:
         ruleset:
            - |  x   x  => 404
            - | ( )  x   => ( )-->( )
            - | (*)  x   => (*)-->( )
            - |  x  ( )  => ( )-->( )
            - |  x  (*)  => ( )-->(*)
            - | ( ) ( )  => ( )-->( )
            - | (*) ( )  => (*)-->( )
            - | ( ) (*)  => ( )-->(*)
            - | (*) (*)  => (*)-->(*)
         cypher: |
            MERGE (s:_ {id: {source}})
            ON CREATE SET s :_:_VACANT
            MERGE (t:_ {id: {target}})
            ON CREATE SET t :_:_VACANT
            WITH s,t
            MERGE (s)-[:«type»]->(r:_:_Rel {id: {id}})-[:«type»]->(t)
            SET r = {doc},
                r.created = timestamp(),
                r.id = {id}
                r.dataset = {dataset}
            RETURN *
      update:
         ruleset:
            - |    x     x     =>  404
            - |   ( )    x     =>  404
            - |   (*)    x     =>  404
            - |    x    ( )    =>  404
            - |    x    (*)    =>  404
            - |   ( )-->( )    =>    ( )-->( )
            - |   (*)-->( )    =>    (*)-->( )
            - |   ( )-->(*)    =>    ( )-->(*)
            - |   (*)-->(*)    =>    (*)-->(*)
         cypher: |
            MATCH (s)-[:«type»]-(r:_:_Rel {id: {id}})-[:«type»]->(t)
            WITH r, coalesce(r.counter, 0) + 1 AS c
            SET r = {doc},
                r.accessTime = timestamp(),
                r.counter = c,
                r.id = {id}
                r.dataset = {dataset}
            RETURN r
      remove:
         ruleset:
            - |    x     x     =>  404
            - |   ( )    x     =>  404
            - |   (*)    x     =>  404
            - |    x    ( )    =>  404
            - |    x    (*)    =>  404
            - |   ( )-->( )    =>     x     x
            - |   (*)-->( )    =>    (*)    x
            - |   ( )-->(*)    =>     x    (*)
            - |   (*)-->(*)    =>    (*)   (*)
            - | --( )-->( )--  =>  --( )   ( )--
            - | --(*)-->( )--  =>  --(*)   ( )--
            - | --( )-->(*)--  =>  --( )   (*)--
            - | --(*)-->(*)--  =>  --(*)   (*)--
            - |   ( )-->( )--  =>   x    ( )--
            - |   (*)-->( )--  =>  (*)   ( )--
            - |   ( )-->(*)--  =>   x    (*)--
            - |   (*)-->(*)--  =>  (*)   (*)--
            - | --( )-->( )    =>  --( )    x
            - | --(*)-->( )    =>  --(*)    x
            - | --( )-->(*)    =>  --( )   (*)
            - | --(*)-->(*)    =>  --(*)   (*)
         cypher: |
            MATCH (s)-[p:«type»]-(r:_:_Rel {id: {id}})-[q:«type»]->(t)
               DELETE p,q,r
            WITH s.id AS source, t.id AS target
            OPTIONAL MATCH (n:_:_VACANT)
               WHERE n.id IN [target, source] AND length( (n)-[]-() ) = 0
               DELETE n
            RETURN true
queries:
   schema:
      cypher: |
         CREATE CONSTRAINT ON (n:_)
         	ASSERT n.id IS UNIQUE
   klont:
      description: expand under all relations
      cypher: |
         MATCH (x:_ {id: {id}})
         	WHERE NOT x:_VACANT
         MATCH (x)-[:«type» *0..8]->(y)
         RETURN DISTINCT y AS n
   haren:
      description: Find all relations adjacent to a klont
      cypher: |
         MATCH (x:_ {id: {id}})
         	WHERE NOT x:_VACANT
         MATCH (x)-[:«type» *0..8]->(y:_)
         WITH DISTINCT y AS n
         OPTIONAL MATCH (y)-[e]-(:_)
         RETURN DISTINCT e
   clean:
      description: Remove all managed nodes and all (including unmanaged) edges between them
      cypher: |
         OPTIONAL MATCH (:_)-[e]-(:_)
         	WITH DISTINCT e AS edge
         	DELETE edge
         	RETURN DISTINCT true AS success
         UNION
         OPTIONAL MATCH (n:_)
         	WITH DISTINCT n AS node
         	DELETE node
         	RETURN DISTINCT true AS success
