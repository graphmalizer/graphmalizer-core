structures:
   node:
      add:
         ruleset:
            - |  x  => (*)
            - | ( ) => (*)
            - | (*) => 500
         cypher: |
            MERGE (n:_:_VACANT:«type» {id: {id}})
            ON CREATE
               SET n = {doc},
                  n.created = timestamp(),
                  n.id = {id}
            ON MATCH
               SET n = {doc},
                   n.accessTime = timestamp(),
                  n.counter = coalesce(n.counter, 0) + 1,
                  n.id = {id}
               REMOVE n:_VACANT
            RETURN n
      update:
         ruleset:
            - |  x  => 404
            - | ( ) => (*)
            - | (*) => (*)
         cypher: |
            MATCH (n:_ {id: {id}})
            WITH n, coalesce(n.counter, 0) + 1 AS c
            SET n = {doc},
                n.accessTime = timestamp(),
               n.counter = c,
               n.id = {id}
            RETURN n
      remove:
         ruleset:
            - |    x  => 404
            - | --( ) => 404
            - |   (*) => x
            - | --(*) => --( )
         cypher: |
            MATCH (n:_ {id: {id}})
            WHERE NOT n:_VACANT
               SET n:_VACANT
               SET n={}
               SET n.id = {id}
            UNION ALL
            OPTIONAL MATCH (n:_:_VACANT {id: {id}})
            WHERE length( (n)--() ) = 0
            DELETE n
            RETURN n
   edge:
      add:
         ruleset:
            - |  x   x  => 404
            - | ( )  x   => ( )-->( )
            - | (*)  x   => (*)-->( )
            - |  x  ( )  => ( )-->( )
            - |  x  (*)  => ( )-->(*)
            - | ( ) ( )  => ( )-->( )
            - | (*) ( )  => (*)-->( )
            - | ( ) (*)  => ( )-->(*)
            - | (*) (*)  => (*)-->(*)
         cypher: |
            MERGE (s:_ {id: {source}})
            ON CREATE SET s :_:_VACANT
            MERGE (t:_ {id: {target}})
            ON CREATE SET t :_:_VACANT
            WITH s,t
            MERGE (s)-[:«type»]->(r:_:_Rel {id: {id}})-[:«type»]->(t)
            SET r = {doc},
                r.created = timestamp(),
                r.id = {id}
            RETURN *
      update:
         ruleset:
            - |    x     x     =>  404
            - |   ( )    x     =>  404
            - |   (*)    x     =>  404
            - |    x    ( )    =>  404
            - |    x    (*)    =>  404
            - |   ( )-->( )    =>    ( )-->( )
            - |   (*)-->( )    =>    (*)-->( )
            - |   ( )-->(*)    =>    ( )-->(*)
            - |   (*)-->(*)    =>    (*)-->(*)
         cypher: |
            MATCH (s)-[:«type»]-(r:_:_Rel {id: {id}})-[:«type»]->(t)
            WITH r, coalesce(r.counter, 0) + 1 AS c
            SET r = {doc},
                r.accessTime = timestamp(),
               r.counter = c,
               r.id = {id}
            RETURN r
      remove:
         ruleset:
            - |    x     x     =>  404
            - |   ( )    x     =>  404
            - |   (*)    x     =>  404
            - |    x    ( )    =>  404
            - |    x    (*)    =>  404
            - |   ( )-->( )    =>     x     x
            - |   (*)-->( )    =>    (*)    x
            - |   ( )-->(*)    =>     x    (*)
            - |   (*)-->(*)    =>    (*)   (*)
            - | --( )-->( )--  =>  --( )   ( )--
            - | --(*)-->( )--  =>  --(*)   ( )--
            - | --( )-->(*)--  =>  --( )   (*)--
            - | --(*)-->(*)--  =>  --(*)   (*)--
            - |   ( )-->( )--  =>   x    ( )--
            - |   (*)-->( )--  =>  (*)   ( )--
            - |   ( )-->(*)--  =>   x    (*)--
            - |   (*)-->(*)--  =>  (*)   (*)--
            - | --( )-->( )    =>  --( )    x
            - | --(*)-->( )    =>  --(*)    x
            - | --( )-->(*)    =>  --( )   (*)
            - | --(*)-->(*)    =>  --(*)   (*)
         cypher: |
            MATCH (s)-[p:«type»]-(r:_:_Rel {id: {id}})-[q:«type»]->(t)
               DELETE p,q,r
            WITH s.id AS source, t.id AS target
            OPTIONAL MATCH (n:_:_VACANT)
               WHERE n.id IN [target, source] AND length( (n)-[]-() ) = 0
               DELETE n
            RETURN true
queries:
   schema:
      cypher: |
         CREATE CONSTRAINT ON (n:_)
         	ASSERT n.id IS UNIQUE
   klont:
      description: expand under all relations
      cypher: |
         MATCH (x:_ {id: {id}})
         	WHERE NOT x:_VACANT
         MATCH (x)-[:«type» *0..8]->(y)
         RETURN DISTINCT y AS n
   haren:
      description: Find all relations adjacent to a klont
      cypher: |
         MATCH (x:_ {id: {id}})
         	WHERE NOT x:_VACANT
         MATCH (x)-[:«type» *0..8]->(y:_)
         WITH DISTINCT y AS n
         OPTIONAL MATCH (y)-[e]-(:_)
         RETURN DISTINCT e
   clean:
      description: Remove all managed nodes and all (including unmanaged) edges between them
      cypher: |
         OPTIONAL MATCH (:_)-[e]-(:_)
         	WITH DISTINCT e AS edge
         	DELETE edge
         	RETURN DISTINCT true AS success
         UNION
         OPTIONAL MATCH (n:_)
         	WITH DISTINCT n AS node
         	DELETE node
         	RETURN DISTINCT true AS success
