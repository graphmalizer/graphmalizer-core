structures:
   node:
      add:
         ruleset:
            - |  x  => (*)
            - | ( ) => (*)
            - | (*) => 500
         cypher: |
            MERGE (n:_:_VACANT {id: {id}})
            ON CREATE
               SET n = {doc},
                  n.created = timestamp(),
                  n.id = {id}
            ON MATCH
               SET n = {doc},
                   n.accessTime = timestamp(),
                  n.counter = coalesce(n.counter, 0) + 1,
                  n.id = {id}
               REMOVE n:_VACANT
            RETURN n
      update:
         ruleset:
            - |  x  => 404
            - | ( ) => (*)
            - | (*) => (*)
         cypher: |
            MATCH (n:_ {id: {id}})
            WITH n, coalesce(n.counter, 0) + 1 AS c
            SET n = {doc},
                n.accessTime = timestamp(),
               n.counter = c,
               n.id = {id}
            RETURN n
      remove:
         ruleset:
            - |    x  => 404
            - | --( ) => 404
            - |   (*) => x
            - | --(*) => --( )
         cypher: |
            MATCH (n:_ {id: {id}})
            WHERE NOT n:_VACANT
               SET n:_VACANT
               SET n={}
               SET n.id = {id}
            UNION ALL
            OPTIONAL MATCH (n:_:_VACANT {id: {id}})
            WHERE length( (n)--() ) = 0
            DELETE n
            RETURN n
   edge:
      add:
         ruleset:
            - |  x   x  => 404
            - | ( )  x   => ( )-->( )
            - | (*)  x   => (*)-->( )
            - |  x  ( )  => ( )-->( )
            - |  x  (*)  => ( )-->(*)
            - | ( ) ( )  => ( )-->( )
            - | (*) ( )  => (*)-->( )
            - | ( ) (*)  => ( )-->(*)
            - | (*) (*)  => (*)-->(*)
         cypher: |
            MERGE (s:_ {id: {source}})
            ON CREATE SET s :_:_VACANT
            MERGE (t:_ {id: {target}})
            ON CREATE SET t :_:_VACANT
            WITH s,t
            MERGE (s)-[e:_ {id: {id}}]->(t)
            SET e = {doc},
               e.created = timestamp(),
               e.id = {id}
            RETURN *
      update:
         ruleset:
            - |    x     x     =>  404
            - |   ( )    x     =>  404
            - |   (*)    x     =>  404
            - |    x    ( )    =>  404
            - |    x    (*)    =>  404
            - |   ( )-->( )    =>    ( )-->( )
            - |   (*)-->( )    =>    (*)-->( )
            - |   ( )-->(*)    =>    ( )-->(*)
            - |   (*)-->(*)    =>    (*)-->(*)
         cypher: |
            MATCH (s)-[e:_ {id: {id}}]-(t)
            WITH e, coalesce(e.counter, 0) + 1 AS c
            SET e = {doc},
                e.accessTime = timestamp(),
               e.counter = c,
               e.id = {id}
            RETURN e
      remove:
         ruleset:
            - |    x     x     =>  404
            - |   ( )    x     =>  404
            - |   (*)    x     =>  404
            - |    x    ( )    =>  404
            - |    x    (*)    =>  404
            - |   ( )-->( )    =>     x     x
            - |   (*)-->( )    =>    (*)    x
            - |   ( )-->(*)    =>     x    (*)
            - |   (*)-->(*)    =>    (*)   (*)
            - | --( )-->( )--  =>  --( )   ( )--
            - | --(*)-->( )--  =>  --(*)   ( )--
            - | --( )-->(*)--  =>  --( )   (*)--
            - | --(*)-->(*)--  =>  --(*)   (*)--
            - |   ( )-->( )--  =>   x    ( )--
            - |   (*)-->( )--  =>  (*)   ( )--
            - |   ( )-->(*)--  =>   x    (*)--
            - |   (*)-->(*)--  =>  (*)   (*)--
            - | --( )-->( )    =>  --( )    x
            - | --(*)-->( )    =>  --(*)    x
            - | --( )-->(*)    =>  --( )   (*)
            - | --(*)-->(*)    =>  --(*)   (*)
         cypher: |
            MATCH (s)-[e:_ {id: {id}}]-(t)
               DELETE e
            WITH s.id AS source, t.id AS target
            OPTIONAL MATCH (n:_:_VACANT)
               WHERE n.id IN [target, source] AND length( (n)-[]-() ) = 0
               DELETE n
            RETURN true
queries:
   klont:
      description: expand under all relations
      cypher: |
         MATCH (x:_ {id: {id}})
         		WHERE NOT x:_VACANT
         		RETURN x AS n
         UNION
         	MATCH (x:_ {id: {id}})
         	MATCH (x)-[:_*]->(y)
         	RETURN DISTINCT y AS n

   clean:
      description: Return all managed nodes and edges
      cypher: |
         OPTIONAL MATCH ()-[e:_]-()
         	DELETE e
         	RETURN DISTINCT true AS success
         UNION
         OPTIONAL MATCH (n:_)
         	DELETE n
         	RETURN DISTINCT true AS success
